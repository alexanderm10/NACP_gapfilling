summary(ring.data)
ring.data$RW0 <- ring.data$RW
ring.data[is.na(ring.data$RW), "RW0"] <- 0
summary(ring.data$RW)
summary(ring.data)
m1 <- gamm(RW0 ~ s(Year, bs="cs", k=3) + species, random=list(site=~1), data=ring.data, na.action=na.omit)
ring.data$RW.m1 <- predict(m1, ring.data)
summary(ring.data)
plot(m1$gam)
m1 <- gamm(RW0 ~ s(Year, bs="cs", k=3, by=TreeID) + species, random=list(site=~1), data=tree.data.full, na.action=na.omit)
m1 <- gamm(RW0 ~ s(Year, bs="cs", k=3, by=TreeID) + species, random=list(site=~1), data=trees.dated.full, na.action=na.omit)
m1 <- gamm(RW0 ~ s(Year, bs="cs", k=3, by=TreeID) + species, random=list(site=~1), data=ring.data[ring.data$TreeID %in% unique(ring.data$TreeID)[1:10],], na.action=na.omit)
plot(m1$gam)
ring.data$RW.m1 <- predict(m1, ring.data)
ring.data$RW0 <- ring.data$RW#
ring.data[is.na(ring.data$RW), "RW0"] <- 0#
summary(ring.data)#
#
m1 <- gamm(RW0 ~ s(Year, bs="cs", k=3, by=TreeID) + species, random=list(site=~1), data=ring.data, na.action=na.omit)
m1 <- gamm(RW0 ~ s(Year, bs="cs", k=3, by=TreeID), random=list(site=~1), data=ring.data, na.action=na.omit)
par(mfrow=c(4,5), mar=c(2,2,0,0)+0.1)#
plot(m1$gam)
ring.data$RW.m1 <- predict(m1, ring.data)
summary(ring.data)
m1 <- gamm(RW0 ~ s(Year, bs="cs", k=3, by=TreeID) + spcies + dbh + canopy.class, random=list(site=~1, PlotID=~1), data=ring.data, na.action=na.omit)
m1 <- gamm(RW0 ~ s(Year, bs="cs", k=3, by=TreeID) + species + dbh + canopy.class, random=list(site=~1, PlotID=~1), data=ring.data, na.action=na.omit)
ring.data$RW.m1 <- predict(m1, ring.data)
summary(ring.data)
par(mfrow=c(4,5), mar=c(2,2,0,0)+0.1)#
plot(m1$gam)
ring.data$RW.m1 <- ifelse(ring.data$RW.m1 < 0, 0, ring.data$RW.m1)
summary(ring.data)
predict0 <- ring.data[,c("TreeID", "Year", "RW.m1")]#
predict0$Year <- as.factor(predict0$Year)#
summary(predict0)
cores.predict <- recast(predict0, Year ~ TreeID)#
#summary(cores.predict)#
cores.predict[1:10,1:10]#
cores.predict[(length(cores.predict[,1])-10):length(cores.predict[,1]),1:10]
for(i in unique(ring.data$TreeID)){#
	plot(RW ~ Year, data=ring.data[ring.data$TreeID==i,], xlim=range(Year, na.rm=T), ylim=range(RW, na.rm=T))#
}
for(i in unique(ring.data$TreeID)){#
	plot(RW ~ Year, data=ring.data[ring.data$TreeID==i,], type="l", xlim=range(Year, na.rm=T), ylim=range(RW, na.rm=T))#
	par(new=T)#
}
for(i in unique(ring.data$TreeID)){#
	plot(RW ~ Year, data=ring.data[ring.data$TreeID==i,], #
	type="l", lty=0.5, xlim=range(ring.data$Year, na.rm=T), ylim=range(ring.data$RW, na.rm=T))#
	par(new=T)#
}
range(ring.data$RW, na.rm=T)
par(new=F)
for(i in unique(ring.data$TreeID)){#
	plot(RW ~ Year, data=ring.data[ring.data$TreeID==i,], #
	type="l", lty=0.5, xlim=range(ring.data$Year, na.rm=T), ylim=range(ring.data$RW, na.rm=T))#
	par(new=T)#
}
for(i in unique(ring.data$TreeID)){#
	plot(RW ~ Year, data=ring.data[ring.data$TreeID==i,], type="l", lty=0.5, xlim=range(ring.data$Year, na.rm=T), ylim=range(ring.data$RW, na.rm=T))#
	par(new=T)#
}
for(i in unique(ring.data$TreeID)){#
	plot(RW ~ Year, data=ring.data[ring.data$TreeID==i,], lty=0.5, xlim=range(ring.data$Year, na.rm=T), ylim=range(ring.data$RW, na.rm=T))#
	par(new=T)#
}
?plot
for(i in unique(ring.data$TreeID)){#
	plot(RW ~ Year, data=ring.data[ring.data$TreeID==i,], type="l", lty=0.5, xlim=range(ring.data$Year, na.rm=T), ylim=range(ring.data$RW, na.rm=T))#
	par(new=T)#
}
for(i in unique(ring.data$TreeID)){#
	plot(RW ~ Year, data=ring.data[ring.data$TreeID==i,], type="l", ylim=range(ring.data$RW, na.rm=T))#
	par(new=T)#
}
for(i in unique(ring.data$TreeID)){#
	plot(RW ~ Year, data=ring.data[ring.data$TreeID==i,], type="l", ylim=range(ring.data$RW, na.rm=T), xlim=c(1900,2020))#
	par(new=T)#
}
for(i in unique(ring.data$TreeID)){#
	plot(RW ~ Year, data=ring.data[ring.data$TreeID==i,], type="l", lwd=0.5, xlim=range(ring.data$Year, na.rm=T), ylim=range(ring.data$RW, na.rm=T))#
	par(new=T)#
}
for(i in unique(ring.data$TreeID)){#
	plot(RW.m1 ~ Year, data=ring.data[ring.data$TreeID==i & is.na(ring.data$RW),], type="l", lwd=0.5, col="red", xlim=range(ring.data$Year, na.rm=T), ylim=range(ring.data$RW, na.rm=T))#
	par(new=T)#
}
m1 <- lme(RW ~ I(exp(Year)) + species + dbh, random=list(site=~1, PlotID=~1, TreeID=~1), data=ring.data, na.action=na.omit)
m1 <- lme(RW ~ I(exp(Year)), random=list(site=~1, PlotID=~1, TreeID=~1), data=ring.data, na.action=na.omit)
m1 <- lme(RW ~ exp(Year), random=list(site=~1, PlotID=~1, TreeID=~1), data=ring.data, na.action=na.omit)
?exp
m1 <- lme(RW ~ I(Year^2), random=list(site=~1, PlotID=~1, TreeID=~1), data=ring.data, na.action=na.omit)
m1 <- lme(RW ~ I(exp(Year)), random=list(site=~1, PlotID=~1, TreeID=~1), data=ring.data, na.action=na.omit)
summary(ring.data)
m1 <- lme(log(RW) ~ Year, random=list(site=~1, PlotID=~1, TreeID=~1), data=ring.data, na.action=na.omit)
ring.data$RW0b <- ring.data$RW#
ring.data[ring.data$RW==0, "RW0b"] <- 1e-5#
summary(ring.data)
m1 <- lme(RW ~ I(exp(Year)), random=list(site=~1, PlotID=~1, TreeID=~1), data=ring.data, na.action=na.omit)
m1 <- lme(RW0b ~ I(exp(Year)), random=list(site=~1, PlotID=~1, TreeID=~1), data=ring.data, na.action=na.omit)
m1 <- lme(log(RW0b) ~ Year, random=list(site=~1, PlotID=~1, TreeID=~1), data=ring.data, na.action=na.omit)
log(RW0b)
log(ring.dataRW0b)
log(ring.data$RW0b)
m1 <- lme(log(ring.data$RW0b) ~ Year, random=list(site=~1, PlotID=~1, TreeID=~1), data=ring.data, na.action=na.omit)
m1 <- lme(log(RW0b) ~ Year, random=list(site=~1, PlotID=~1, TreeID=~1), data=ring.data, na.action=na.omit)
m1 <- lme(RW ~ Year, random=list(site=~1, PlotID=~1, TreeID=~1), data=ring.data, na.action=na.omit)
m1 <- lme(RW ~ Year + species*dbh*canopy.class, random=list(site=~1, PlotID=~1, TreeID=~1), data=ring.data, na.action=na.omit)
m1 <- lme(RW ~ Year + species + dbh*canopy.class, random=list(site=~1, PlotID=~1, TreeID=~1), data=ring.data, na.action=na.omit)
m1 <- r.squaredGLMM(m1$lme)
m1 <- r.squaredGLMM(m1)
ring.data$RW.m1 <- predict(m1, ring.data)#
summary(ring.data)
m1 <- lme(RW ~ Year + species*dbh, random=list(site=~1, PlotID=~1, TreeID=~1), data=ring.data, na.action=na.omit)
m1 <- lme(RW ~ Year + species + dbh, random=list(site=~1, PlotID=~1, TreeID=~1), data=ring.data, na.action=na.omit)
ring.data$RW.m1 <- predict(m1, ring.data)#
summary(ring.data)#
#
# Getting rid of negative ring width because they're impossible --> replacing with 0 to help with later#
ring.data$RW.m1 <- ifelse(ring.data$RW.m1 < 0, 0, ring.data$RW.m1)#
summary(ring.data)#
#
for(i in unique(ring.data$TreeID)){#
	plot(RW ~ Year, data=ring.data[ring.data$TreeID==i,], type="l", lwd=0.5, xlim=range(ring.data$Year, na.rm=T), ylim=range(ring.data$RW, na.rm=T))#
	par(new=T)#
}#
for(i in unique(ring.data$TreeID)){#
	plot(RW.m1 ~ Year, data=ring.data[ring.data$TreeID==i & is.na(ring.data$RW),], type="l", lwd=0.5, col="red", xlim=range(ring.data$Year, na.rm=T), ylim=range(ring.data$RW, na.rm=T))#
	par(new=T)#
}
for(i in unique(ring.data$TreeID)){#
	plot(RW ~ Year, data=ring.data[ring.data$TreeID==i,], type="l", lwd=0.5, xlim=range(ring.data$Year, na.rm=T), ylim=range(ring.data$RW, na.rm=T))#
	par(new=T)#
}#
for(i in unique(ring.data$TreeID)){#
	plot(RW.m1 ~ Year, data=ring.data[ring.data$TreeID==i & is.na(ring.data$RW),], type="p", cex=0.5, col="red", xlim=range(ring.data$Year, na.rm=T), ylim=range(ring.data$RW, na.rm=T))#
	par(new=T)#
}
m1b <- lme(RW ~ Year + species + dbh, random=list(site=~1, PlotID=~1, TreeID=~1), data=ring.data, na.action=na.omit)#
#m1.r2 <- r.squaredGLMM(m1$lme)#
#m1.r2 # R2m = 0.5227, R2c = 0.6785
m1 <- gamm(RW0 ~ s(Year, bs="cs", k=3, by=TreeID) + species + dbh + canopy.class, random=list(site=~1, PlotID=~1), data=ring.data, na.action=na.omit)
ring.data$RW.m1 <- predict(m1, ring.data)
summary(ring.data)
# Getting rid of negative ring width because they're impossible --> replacing with 0 to help with later#
ring.data$RW.m1 <- ifelse(ring.data$RW.m1 < 0, 0, ring.data$RW.m1)#
summary(ring.data)#
#
par(new=T)#
for(i in unique(ring.data$TreeID)){#
	plot(RW ~ Year, data=ring.data[ring.data$TreeID==i,], type="l", lwd=0.5, xlim=range(ring.data$Year, na.rm=T), ylim=range(ring.data$RW, na.rm=T))#
	par(new=T)#
}#
for(i in unique(ring.data$TreeID)){#
	plot(RW.m1 ~ Year, data=ring.data[ring.data$TreeID==i & is.na(ring.data$RW),], type="p", cex=0.5, pch=19, col="red", xlim=range(ring.data$Year, na.rm=T), ylim=range(ring.data$RW, na.rm=T))#
	par(new=T)#
}
m1b <- lme(RW ~ Year + species + dbh, random=list(site=~1, PlotID=~1, TreeID=~1), data=ring.data, na.action=na.omit)
ring.data$RW.m1 <- predict(m1, ring.data)#
ring.data$RW.m1b <- predict(m1b, ring.data)#
summary(ring.data)#
#
# Getting rid of negative ring width because they're impossible --> replacing with 0 to help with later#
ring.data$RW.m1 <- ifelse(ring.data$RW.m1 < 0, 0, ring.data$RW.m1)#
ring.data$RW.m1b <- ifelse(ring.data$RW.m1b < 0, 0, ring.data$RW.m1n)#
summary(ring.data)
par(new=F)#
for(i in unique(ring.data$TreeID)){#
	plot(RW ~ Year, data=ring.data[ring.data$TreeID==i,], type="l", lwd=0.5, xlim=range(ring.data$Year, na.rm=T), ylim=range(ring.data$RW, na.rm=T))#
	par(new=T)#
}#
for(i in unique(ring.data$TreeID)){#
	plot(RW.m1 ~ Year, data=ring.data[ring.data$TreeID==i & is.na(ring.data$RW),], type="p", cex=0.5, pch=19, col="red", xlim=range(ring.data$Year, na.rm=T), ylim=range(ring.data$RW, na.rm=T))#
	par(new=T)#
}#
#
par(new=F)#
for(i in unique(ring.data$TreeID)){#
	plot(RW ~ Year, data=ring.data[ring.data$TreeID==i,], type="l", lwd=0.5, xlim=range(ring.data$Year, na.rm=T), ylim=range(ring.data$RW, na.rm=T), main="GAMM")#
	par(new=T)#
}#
for(i in unique(ring.data$TreeID)){#
	plot(RW.m1 ~ Year, data=ring.data[ring.data$TreeID==i & is.na(ring.data$RW),], type="p", cex=0.5, pch=19, col="red", xlim=range(ring.data$Year, na.rm=T), ylim=range(ring.data$RW, na.rm=T), main="Linear")#
	par(new=T)#
}
par(new=F)#
for(i in unique(ring.data$TreeID)){#
	plot(RW ~ Year, data=ring.data[ring.data$TreeID==i,], type="l", lwd=0.5, xlim=range(ring.data$Year, na.rm=T), ylim=range(ring.data$RW, na.rm=T))#
	par(new=T)#
}#
for(i in unique(ring.data$TreeID)){#
	plot(RW.m1 ~ Year, data=ring.data[ring.data$TreeID==i & is.na(ring.data$RW),], type="p", cex=0.5, pch=19, col="red", xlim=range(ring.data$Year, na.rm=T), ylim=range(ring.data$RW, na.rm=T))#
	par(new=T)#
}#
for(i in unique(ring.data$TreeID)){#
	plot(RW.m1b ~ Year, data=ring.data[ring.data$TreeID==i & is.na(ring.data$RW),], type="p", cex=0.5, pch=19, col="blue", xlim=range(ring.data$Year, na.rm=T), ylim=range(ring.data$RW, na.rm=T))#
	par(new=T)#
}
plot(RW.m1b ~ RW.m1, data=ring.data)
par(new=F)#
plot(RW.m1b ~ RW.m1, data=ring.data)
plot(RW.m1b ~ RW.m1, data=ring.data[is.na(ring.data$RW),])
abline(a=0, b=1, col="red")
plot(RW.m1b ~ RW.m1, pch=19, xlim=c(0,1), ylim=c(0,1), data=ring.data[is.na(ring.data$RW),])#
abline(a=0, b=1, col="red")
par(new=F)#
for(i in unique(ring.data$TreeID)){#
	plot(RW ~ Year, data=ring.data[ring.data$TreeID==i,], type="l", lwd=0.5, xlim=range(ring.data$Year, na.rm=T), ylim=range(ring.data$RW, na.rm=T))#
	par(new=T)#
}#
for(i in unique(ring.data$TreeID)){#
	plot(RW.m1 ~ Year, data=ring.data[ring.data$TreeID==i & is.na(ring.data$RW),], type="p", cex=0.5, pch=19, col="red", xlim=range(ring.data$Year, na.rm=T), ylim=range(ring.data$RW, na.rm=T))#
	par(new=T)#
}#
for(i in unique(ring.data$TreeID)){#
	plot(RW.m1b ~ Year, data=ring.data[ring.data$TreeID==i & is.na(ring.data$RW),], type="p", cex=0.5, pch=19, col="blue", xlim=range(ring.data$Year, na.rm=T), ylim=range(ring.data$RW, na.rm=T))#
	par(new=T)#
}#
par(new=F)
par(new=F)#
for(i in unique(ring.data$TreeID)){#
	plot(RW ~ Year, data=ring.data[ring.data$TreeID==i,], type="l", lwd=0.5, xlim=range(ring.data$Year, na.rm=T), ylim=range(ring.data$RW, na.rm=T))#
	par(new=T)#
}#
for(i in unique(ring.data$TreeID)){#
	plot(RW.m1 ~ Year, data=ring.data[ring.data$TreeID==i & is.na(ring.data$RW),], type="p", cex=0.25, pch=19, col="red", xlim=range(ring.data$Year, na.rm=T), ylim=range(ring.data$RW, na.rm=T))#
	par(new=T)#
}#
# for(i in unique(ring.data$TreeID)){#
	# plot(RW.m1b ~ Year, data=ring.data[ring.data$TreeID==i & is.na(ring.data$RW),], type="p", cex=0.5, pch=19, col="blue", xlim=range(ring.data$Year, na.rm=T), ylim=range(ring.data$RW, na.rm=T))#
	# par(new=T)#
# }#
par(new=F)
summary(tree.data)
summary(tree.data[!is.na(tree.data$Dated),])
summary(cored.ata)
summary(core.data)
summary(core.data[!is.na(core.data$dated),])
test <- core.data[!is.na(core.data$dated),]
plot(DBH ~ pith.yr, data=test)
plot(dbh ~ pith.yr, data=test)
plot(pith.yr ~ dbh, data=test, pch=19)
lm1 <- lm(pith.yr ~ dbh*canopy.class, data=test)
summary(lm1)
lm1 <- lm(pith.yr ~ dbh*canopy.class*species, data=test)
summary(lm1)
?save
save(m1, file="GapFilling_gamm_mmf_2015.01.rData")
library(dplR)#
se <- function(x){#
  sd(x, na.rm=TRUE) / sqrt((length(!is.na(x))))}#
##################################################################################################
# Loading up .csv file that has meta data and RWL files for ring widths#
# Also doing some housekeeping (unit conversions, name formats) up front to make the workflow smoother#
##################################################################################################
#
#importing the diameter files of all trees sampled: includes tree id, spp, plot assignment, and DBH #
#loading the dplR to use the basal area reconstruction functions.#
#
core.data <- read.csv("Core_data_DOE_summer_2014.csv", na.strings=c("", "NA", "#VALUE!", "*"), header=T)#
#adding a column include which plot at the site the trees belong to#
names(core.data)#
core.data$plot <- substr(core.data$plot.id, 3, 3)#
core.data$plot <- as.factor(core.data$plot)#
#
summary(core.data)#
#
tree.data <- read.csv("Copy of DOE_field_notes_2014_updated_MMB spp.csv", na.strings=c("", "NA", "#VALUE!", "*"), header=T)#
#adding a column include which plot at the site the trees belong to#
names(tree.data)#
tree.data$plot <- substr(tree.data$PlotID, 3, 3)#
tree.data$plot <- as.factor(tree.data$plot)#
#
summary(tree.data)#
#load in core details data sheet.  Has living/dead, pith info, measurement info.#
#importing ring widths of dated samples as an object and making plot a factor since there were two distinct plots.  We may remove this for the nested design.  #
#Removing NA's from the files#
# FUTURE NOTE: need to create a generalizeable file to house all RW measurements#
core.rw <- read.rwl("mmf_all_trees.rwl")#
head(core.rw)#
summary(core.rw)#
#
#removing the extra character that tellervo adds#
names(core.rw)<-substr(names(core.rw), 1, 7)#
names(core.rw)#
#
# NOTE: Unit Conversion Step#
#we divide by 10 here because we are in mm going to cm (as long as you upload with dplR) #
summary(core.rw)#
core.rw <- core.rw/10#
summary(core.rw)#
# ----------------------------------------------------------------------------#
#add zeros to the outside if the tree is dead.  We do not want to generate modeled values for dead or zombie trees!#
# Separating Dead vs. Missing rings#
# What we need to know:#
#1) Dead trees -- fill missing years with 0#
#2) Live Trees, no growth in year (Zombie Trees) -- fill with 0#
#3) Live Trees, missing part of core -- model growth#
#
# CRR Note: This sets up what data gets gapfilled on the outside vs. which should have 0 growth in the most recent years#
#
for(j in colnames(core.rw)){ # rather than going by number, we're using names to make things a bit clearer#
#
	# If the core is a zombie or is dead, fill missing outer rings with 0s, otherwise it gets left alone#
	# NOTE: We may need to add another level here if you have cores from multiple years so that things that were cored in a prior year also get 0s (so they don't get gapfilled outsides)#
	if(!is.na(core.data[core.data$CoreID==j, "zombie"]) | core.data[core.data$CoreID==j, "live.dead"]=="DEAD"){ #
		last.meas <- as.numeric(core.data[core.data$CoreID==j, "outer.measured"]) # last ring which was mesured#
	 	last.yr <- as.numeric(max(row.names(core.rw))) # oldest year in the data frame (this makes it flexible in case you add 2015 cores)#
		if(!(last.meas = last.yr)){ # only do the 0 replacement if there are rows that need to be filled#
			inner.fill <- which(row.names(core.rw)== last.meas+1)#
			outer.fill <- which(row.names(core.rw)==last.yr)#
			core.rw[inner.fill:outer.fill,j] <- 0#
		}#
	}#
}#
summary(core.rw)#
# ----------------------------------------------------------------------------
###########################################################################
#AGGREGATION STEP#
#taking ring widths and aggregating from the core level to the tree level#
###########################################################################
# ----------------------------------------------------------------------------#
# aggregate to the tree level using only dated trees where possible#
trees <- unique(substr(names(core.rw), 1, 6)) # listing trees we have measurements for#
tree.rw <- data.frame(array(NA, dim=c(nrow(core.rw), length(trees)))) # a blank data frame to put everything in#
row.names(tree.rw) <- row.names(core.rw)  # labeling the rows with the years from our rwl#
names(tree.rw)<-unique(substr(names(core.rw), 1, 6)) # labeling the columns as trees#
# summary(tree.rw) # this will get really big very quickly#
dim(tree.rw) # 90 trees, 112 years of data
i <- names(core.rw)[1]
i
row.names(core.rw[!is.na(core.rw[,i]),i])
core.rw[!is.na(core.rw[,i]),i]
row.names(core.rw[!is.na(core.rw[,i]),i])
row.names(core.rw[!is.na(core.rw[,i]),])
as.numeric(row.names(core.rw[!is.na(core.rw[,i]),]))
min(as.numeric(row.names(core.rw[!is.na(core.rw[,i]),])))
summary(ring.data)
summary(core.data)
# The Aggregation Loop#
for(i in unique(trees)){#
  cols <- which(substr(names(core.rw),1,6)==i) # getting the columns we're working with#
  cores <- names(core.rw)[cols] # getting the name of the cores we're working with#
  # -----------------------#
  # if there's only one core, we just take that regardless of wheter it's dated or not#
  if(length(cols) == 1){ #
   	tree.rw[,which(trees==i)] <- core.rw[,cols]#
#
	# if that single core is dated, list the tree as dated ("Y"); if not, list as not ("N")#
   	ifelse(core.data[core.data$CoreID==cores, "dated"]=="Y", tree.data[tree.data$TreeID==i, "Dated"] <- "Y", tree.data[tree.data$TreeID==i, "Dated"] <- "N")#
	# Finding a (best-guess) pith date for the tree#
   	tree.data[core.data$CoreID, "Pith"] <- ring.data[ring.data$CoreID==cores, "pith.yr"]#
  # -----------------------#
#
  	} else { #
#
    # -----------------------#
  	# if there's more than 1 core, we need to figure out which if any were dated#
  	use <- vector(length=length(cols))#
	for(x in 1:length(cols)){#
		ifelse(core.data[core.data$CoreID==cores[x], "dated"]=="Y", use[x] <- "TRUE", use[x] <- "FALSE")#
	 }	#
    # -----------------------#
#
    # -----------------------#
	# now we know which were dated, so we can use that to figure out which cores to average#
	if(length(use[use=="TRUE"])==1) { #
		# if only 1 core is dated, use only that core and call the tree dated#
  	 	tree.rw[,which(trees==i)] <- core.rw[,cols[which(use=="TRUE")]]#
  	 	tree.data[tree.data$TreeID==i, "Dated"] <- "Y"#
   		tree.data[core.data$CoreID, "Pith"] <- ring.data[ring.data$CoreID==cores[which(use=="TRUE")], "pith.yr"]#
#
    # -----------------------#
#
	} else if(length(use[use=="TRUE"])>1) { #
    # -----------------------#
    # If there's greater than one dated core, take the mean of the dated cores and call the tree dated#
		tree.rw[,which(trees==i)] <- rowMeans(core.rw[,cols[which(use=="TRUE")]], na.rm=T)#
		tree.data[tree.data$TreeID==i, "Dated"] <- "Y"#
   		tree.data[core.data$CoreID, "Pith"] <- mean(ring.data[ring.data$CoreID==cores[which(use=="TRUE")], "pith.yr"], na.rm=T)#
#
	} else { #
    # -----------------------#
    # If no cores are dated, take the mean of whatever we have and call the tree undated#
		tree.rw[,which(trees==i)] <- rowMeans(core.rw[,cols], na.rm=T) #
		tree.data[tree.data$TreeID==i, "Dated"] <- "N"#
   		tree.data[core.data$CoreID, "Pith"] <- mean(ring.data[ring.data$CoreID==cores], "pith.yr"], na.rm=T)#
    # -----------------------#
	}#
  }#
}
# The Aggregation Loop#
for(i in unique(trees)){#
  cols <- which(substr(names(core.rw),1,6)==i) # getting the columns we're working with#
  cores <- names(core.rw)[cols] # getting the name of the cores we're working with#
  # -----------------------#
  # if there's only one core, we just take that regardless of wheter it's dated or not#
  if(length(cols) == 1){ #
   	tree.rw[,which(trees==i)] <- core.rw[,cols]#
#
	# if that single core is dated, list the tree as dated ("Y"); if not, list as not ("N")#
   	ifelse(core.data[core.data$CoreID==cores, "dated"]=="Y", tree.data[tree.data$TreeID==i, "Dated"] <- "Y", tree.data[tree.data$TreeID==i, "Dated"] <- "N")#
	# Finding a (best-guess) pith date for the tree#
   	tree.data[core.data$CoreID, "Pith"] <- ring.data[ring.data$CoreID==cores, "pith.yr"]#
  # -----------------------#
#
  	} else { #
#
    # -----------------------#
  	# if there's more than 1 core, we need to figure out which if any were dated#
  	use <- vector(length=length(cols))#
	for(x in 1:length(cols)){#
		ifelse(core.data[core.data$CoreID==cores[x], "dated"]=="Y", use[x] <- "TRUE", use[x] <- "FALSE")#
	 }	#
    # -----------------------#
#
    # -----------------------#
	# now we know which were dated, so we can use that to figure out which cores to average#
	if(length(use[use=="TRUE"])==1) { #
		# if only 1 core is dated, use only that core and call the tree dated#
  	 	tree.rw[,which(trees==i)] <- core.rw[,cols[which(use=="TRUE")]]#
  	 	tree.data[tree.data$TreeID==i, "Dated"] <- "Y"#
   		tree.data[core.data$CoreID, "Pith"] <- ring.data[ring.data$CoreID==cores[which(use=="TRUE")], "pith.yr"]#
#
    # -----------------------#
#
	} else if(length(use[use=="TRUE"])>1) { #
    # -----------------------#
    # If there's greater than one dated core, take the mean of the dated cores and call the tree dated#
		tree.rw[,which(trees==i)] <- rowMeans(core.rw[,cols[which(use=="TRUE")]], na.rm=T)#
		tree.data[tree.data$TreeID==i, "Dated"] <- "Y"#
   		tree.data[core.data$CoreID, "Pith"] <- mean(ring.data[ring.data$CoreID==cores[which(use=="TRUE")], "pith.yr"], na.rm=T)#
#
	} else { #
    # -----------------------#
    # If no cores are dated, take the mean of whatever we have and call the tree undated#
		tree.rw[,which(trees==i)] <- rowMeans(core.rw[,cols], na.rm=T) #
		tree.data[tree.data$TreeID==i, "Dated"] <- "N"#
   		tree.data[core.data$CoreID, "Pith"] <- mean(ring.data[ring.data$CoreID==cores, "pith.yr"], na.rm=T)#
    # -----------------------#
	}#
  }#
}
# The Aggregation Loop#
for(i in unique(trees)){#
  cols <- which(substr(names(core.rw),1,6)==i) # getting the columns we're working with#
  cores <- names(core.rw)[cols] # getting the name of the cores we're working with#
  # -----------------------#
  # if there's only one core, we just take that regardless of wheter it's dated or not#
  if(length(cols) == 1){ #
   	tree.rw[,which(trees==i)] <- core.rw[,cols]#
#
	# if that single core is dated, list the tree as dated ("Y"); if not, list as not ("N")#
   	ifelse(core.data[core.data$CoreID==cores, "dated"]=="Y", tree.data[tree.data$TreeID==i, "Dated"] <- "Y", tree.data[tree.data$TreeID==i, "Dated"] <- "N")#
	# Finding a (best-guess) pith date for the tree#
   	tree.data[tree.data$TreeID==i, "Pith"] <- core.data[core.data$CoreID==cores, "pith.yr"]#
  # -----------------------#
#
  	} else { #
#
    # -----------------------#
  	# if there's more than 1 core, we need to figure out which if any were dated#
  	use <- vector(length=length(cols))#
	for(x in 1:length(cols)){#
		ifelse(core.data[core.data$CoreID==cores[x], "dated"]=="Y", use[x] <- "TRUE", use[x] <- "FALSE")#
	 }	#
    # -----------------------#
#
    # -----------------------#
	# now we know which were dated, so we can use that to figure out which cores to average#
	if(length(use[use=="TRUE"])==1) { #
		# if only 1 core is dated, use only that core and call the tree dated#
  	 	tree.rw[,which(trees==i)] <- core.rw[,cols[which(use=="TRUE")]]#
  	 	tree.data[tree.data$TreeID==i, "Dated"] <- "Y"#
   		tree.data[tree.data$TreeID==i, "Pith"] <- core.data[core.data$CoreID==cores[which(use=="TRUE")], "pith.yr"]#
#
    # -----------------------#
#
	} else if(length(use[use=="TRUE"])>1) { #
    # -----------------------#
    # If there's greater than one dated core, take the mean of the dated cores and call the tree dated#
		tree.rw[,which(trees==i)] <- rowMeans(core.rw[,cols[which(use=="TRUE")]], na.rm=T)#
		tree.data[tree.data$TreeID==i, "Dated"] <- "Y"#
   		tree.data[tree.data$TreeID==i, "Pith"] <- mean(core.data[core.data$CoreID==cores[which(use=="TRUE")], "pith.yr"], na.rm=T)#
#
	} else { #
    # -----------------------#
    # If no cores are dated, take the mean of whatever we have and call the tree undated#
		tree.rw[,which(trees==i)] <- rowMeans(core.rw[,cols], na.rm=T) #
		tree.data[tree.data$TreeID==i, "Dated"] <- "N"#
   		tree.data[tree.data$TreeID==i, "Pith"] <- mean(core.data[core.data$CoreID==cores, "pith.yr"], na.rm=T)#
    # -----------------------#
	}#
  }#
}#
# summary(tree.rw)#
min(tree.rw, na.rm=T); max(tree.rw, na.rm=T)#
dim(tree.rw)
warnings()
summary(tree.data)
i
i <- names(cores.rw)[1]
i <- names(core.rw)[1]
i
cols <- which(substr(names(core.rw),1,6)==i) # getting the columns we're working with
cores <- names(core.rw)[cols] # getting the name of the cores we're working with
cores
cols
which(substr(names(core.rw),1,6)==i)
i
substr(names(core.rw),1,6)
which(substr(names(core.rw),1,6)==i)
cols <- names(core.rw(which(substr(names(core.rw),1,6)==i)) # getting the columns we're working with
)
library(dplR)#
se <- function(x){#
  sd(x, na.rm=TRUE) / sqrt((length(!is.na(x))))}#
##################################################################################################
# Loading up .csv file that has meta data and RWL files for ring widths#
# Also doing some housekeeping (unit conversions, name formats) up front to make the workflow smoother#
##################################################################################################
#
#importing the diameter files of all trees sampled: includes tree id, spp, plot assignment, and DBH #
#loading the dplR to use the basal area reconstruction functions.#
#
core.data <- read.csv("Core_data_DOE_summer_2014.csv", na.strings=c("", "NA", "#VALUE!", "*"), header=T)#
#adding a column include which plot at the site the trees belong to#
names(core.data)#
core.data$plot <- substr(core.data$plot.id, 3, 3)#
core.data$plot <- as.factor(core.data$plot)#
#
summary(core.data)#
#
tree.data <- read.csv("Copy of DOE_field_notes_2014_updated_MMB spp.csv", na.strings=c("", "NA", "#VALUE!", "*"), header=T)#
#adding a column include which plot at the site the trees belong to#
names(tree.data)#
tree.data$plot <- substr(tree.data$PlotID, 3, 3)#
tree.data$plot <- as.factor(tree.data$plot)#
#
summary(tree.data)#
#load in core details data sheet.  Has living/dead, pith info, measurement info.#
#importing ring widths of dated samples as an object and making plot a factor since there were two distinct plots.  We may remove this for the nested design.  #
#Removing NA's from the files#
# FUTURE NOTE: need to create a generalizeable file to house all RW measurements#
core.rw <- read.rwl("mmf_all_trees.rwl")#
head(core.rw)#
summary(core.rw)#
#
#removing the extra character that tellervo adds#
names(core.rw)<-substr(names(core.rw), 1, 7)#
names(core.rw)#
#
# NOTE: Unit Conversion Step#
#we divide by 10 here because we are in mm going to cm (as long as you upload with dplR) #
summary(core.rw)#
core.rw <- core.rw/10#
summary(core.rw)#
# ----------------------------------------------------------------------------#
#add zeros to the outside if the tree is dead.  We do not want to generate modeled values for dead or zombie trees!#
# Separating Dead vs. Missing rings#
# What we need to know:#
#1) Dead trees -- fill missing years with 0#
#2) Live Trees, no growth in year (Zombie Trees) -- fill with 0#
#3) Live Trees, missing part of core -- model growth#
#
# CRR Note: This sets up what data gets gapfilled on the outside vs. which should have 0 growth in the most recent years#
#
for(j in colnames(core.rw)){ # rather than going by number, we're using names to make things a bit clearer#
#
	# If the core is a zombie or is dead, fill missing outer rings with 0s, otherwise it gets left alone#
	# NOTE: We may need to add another level here if you have cores from multiple years so that things that were cored in a prior year also get 0s (so they don't get gapfilled outsides)#
	if(!is.na(core.data[core.data$CoreID==j, "zombie"]) | core.data[core.data$CoreID==j, "live.dead"]=="DEAD"){ #
		last.meas <- as.numeric(core.data[core.data$CoreID==j, "outer.measured"]) # last ring which was mesured#
	 	last.yr <- as.numeric(max(row.names(core.rw))) # oldest year in the data frame (this makes it flexible in case you add 2015 cores)#
		if(!(last.meas = last.yr)){ # only do the 0 replacement if there are rows that need to be filled#
			inner.fill <- which(row.names(core.rw)== last.meas+1)#
			outer.fill <- which(row.names(core.rw)==last.yr)#
			core.rw[inner.fill:outer.fill,j] <- 0#
		}#
	}#
}#
summary(core.rw)#
# ----------------------------------------------------------------------------
trees <- unique(substr(names(core.rw), 1, 6)) # listing trees we have measurements for#
tree.rw <- data.frame(array(NA, dim=c(nrow(core.rw), length(trees)))) # a blank data frame to put everything in#
row.names(tree.rw) <- row.names(core.rw)  # labeling the rows with the years from our rwl#
names(tree.rw)<-unique(substr(names(core.rw), 1, 6)) # labeling the columns as trees#
# summary(tree.rw) # this will get really big very quickly#
dim(tree.rw) # 90 trees, 112 years of data
i <- trees[1]
i
cols <- which(substr(names(core.rw),1,6)==i) # getting the columns we're working with
cols
cores <- names(core.rw)[cols] # getting the name of the cores we're working with
cores
length(cols) == 1
tree.rw[,which(trees==i)] <- core.rw[,cols]
core.data[core.data$CoreID==cores, "dated"]=="Y"
tree.data[tree.data$TreeID==i, "Dated"] <- "N"
tree.data[tree.data$TreeID==i, "Pith"] <- core.data[core.data$CoreID==cores, "pith.yr"]
tree.data[tree.data$TreeID==i, "Pith"]
i <- trees[2]
i
cols <- which(substr(names(core.rw),1,6)==i) # getting the columns we're working with
cols
cores
cols
cores <- names(core.rw)[cols] # getting the name of the cores we're working with
cores
length(cols) == 1
use <- vector(length=length(cols))#
	for(x in 1:length(cols)){#
		ifelse(core.data[core.data$CoreID==cores[x], "dated"]=="Y", use[x] <- "TRUE", use[x] <- "FALSE")#
	 }
use
length(use[use=="TRUE"])==1
length(use[use=="TRUE"])>1
tree.rw[,which(trees==i)] <- rowMeans(core.rw[,cols], na.rm=T)
tree.rw[,which(trees==i)]
tree.data[tree.data$TreeID==i, "Dated"] <- "N"
tree.data[tree.data$TreeID==i, "Dated"]
tree.data[tree.data$TreeID==i, "Pith"] <- mean(core.data[core.data$CoreID==cores, "pith.yr"], na.rm=T)
mean(core.data[core.data$CoreID==cores, "pith.yr"], na.rm=T)
core.data[core.data$CoreID==cores, "pith.yr"]
core.data[core.data$CoreID==cores,
]
# The Aggregation Loop#
for(i in unique(trees)){#
  cols <- which(substr(names(core.rw),1,6)==i) # getting the columns we're working with#
  cores <- names(core.rw)[cols] # getting the name of the cores we're working with#
  # -----------------------#
  # if there's only one core, we just take that regardless of wheter it's dated or not#
  if(length(cols) == 1){ #
   	tree.rw[,which(trees==i)] <- core.rw[,cols]#
#
	# if that single core is dated, list the tree as dated ("Y"); if not, list as not ("N")#
   	ifelse(core.data[core.data$CoreID==cores, "dated"]=="Y", tree.data[tree.data$TreeID==i, "Dated"] <- "Y", tree.data[tree.data$TreeID==i, "Dated"] <- "N")#
	# Finding a (best-guess) pith date for the tree#
   	tree.data[tree.data$TreeID==i, "Pith"] <- core.data[core.data$CoreID==cores, "pith.yr"]#
  # -----------------------#
#
  	} else { #
#
    # -----------------------#
  	# if there's more than 1 core, we need to figure out which if any were dated#
  	use <- vector(length=length(cols))#
	for(x in 1:length(cols)){#
		ifelse(core.data[core.data$CoreID==cores[x], "dated"]=="Y", use[x] <- "TRUE", use[x] <- "FALSE")#
	 }	#
    # -----------------------#
#
    # -----------------------#
	# now we know which were dated, so we can use that to figure out which cores to average#
	if(length(use[use=="TRUE"])==1) { #
		# if only 1 core is dated, use only that core and call the tree dated#
  	 	tree.rw[,which(trees==i)] <- core.rw[,cols[which(use=="TRUE")]]#
  	 	tree.data[tree.data$TreeID==i, "Dated"] <- "Y"#
   		tree.data[tree.data$TreeID==i, "Pith"] <- core.data[core.data$CoreID==cores[which(use=="TRUE")], "pith.yr"]#
#
    # -----------------------#
#
	} else if(length(use[use=="TRUE"])>1) { #
    # -----------------------#
    # If there's greater than one dated core, take the mean of the dated cores and call the tree dated#
		tree.rw[,which(trees==i)] <- rowMeans(core.rw[,cols[which(use=="TRUE")]], na.rm=T)#
		tree.data[tree.data$TreeID==i, "Dated"] <- "Y"#
   		tree.data[tree.data$TreeID==i, "Pith"] <- mean(core.data[core.data$CoreID==cores[which(use=="TRUE")], "pith.yr"], na.rm=T)#
#
	} else { #
    # -----------------------#
    # If no cores are dated, take the mean of whatever we have and call the tree undated#
		tree.rw[,which(trees==i)] <- rowMeans(core.rw[,cols], na.rm=T) #
		tree.data[tree.data$TreeID==i, "Dated"] <- "N"#
   		tree.data[tree.data$TreeID==i, "Pith"] <- mean(core.data[core.data$CoreID==cores, "pith.yr"], na.rm=T)#
    # -----------------------#
	}#
  }#
}#
# summary(tree.rw)#
min(tree.rw, na.rm=T); max(tree.rw, na.rm=T)#
dim(tree.rw)
summary(tree.data)
tree.data$Dated <- as.factor(tree.data$Dated)#
summary(tree.data)
write.csv(tree.data, "TreeData.csv", row.names=F)
# ----------------------------------------------------------------------------#
# ----------------------------------------------------------------------------#
# CRR: writing our tree RWL to a csv formatted for gap filling before we calculate BAI (bc some have missing outsides and that's bad if we're working outside-in in out calculations)#
#
# stacking the RWL so that we have a single column of ring widths & an identifying column with TreeID#
tree.stack <- stack(tree.rw)#
names(tree.stack) <- c("RW", "TreeID")#
tree.stack$Year <- as.numeric(row.names(tree.rw)) # adding in the years#
summary(tree.stack)#
#
# attaching all of our useful tree data#
summary(tree.data)#
tree.stack <- merge(tree.stack, tree.data, all.x=T, all.y=F)#
summary(tree.stack)#
dim(tree.stack)#
#
write.csv(tree.stack, "TreeRWL_stacked.csv", row.names=F)
# importing libraries#
library(dplR)#
library(lattice)#
#
# Getting Libraries#
library(reshape)#
library(car)#
library(mgcv)#
library(nlme)#
library(lmeSplines)#
#library(lme4)#
library(splines)#
library(MASS)#
library(MuMIn)#
library(ggplot2)#
library(grid)#
se <- function(x){#
	sd(x, na.rm=TRUE) / sqrt((length(!is.na(x))))}#
#
q.blank <- theme(axis.line=element_line(color="black", size=0.5), panel.grid.major=element_blank(), panel.grid.minor= element_blank(), panel.border= element_blank(), panel.background= element_blank(), axis.text.x=element_text(angle=0, color="black", size=14, face="bold"), axis.text.y=element_text(color="black", size=12, face="bold"), axis.title.x=element_text(face="bold", size=14),  axis.title.y=element_text(face="bold", size=14))#
##################################################################################################
# STEP 1: Gap-filling measured trees#
# STEP 1b: Pith-correction in measured trees (useful for stand dynamics; won't do unless you ask for it)#
# STEP 2: Gap-filling missing trees#
##
# BIG SELLING POINT OF THIS APPROACH: we can quantify different levels of uncertainty & variability#
# Caveats: fitting the initial GAMM is very time-intensive (it may take hours with your full data) because current form fits a spline to each tree in a mixed model framework#
#
##################################################################################################
# Previous workflow#
# 1) Read in RWL, QA/QC#
# 3) Aggregate to tree (factoring in whether cores were dated) level & decide if an entire tree is dated or not -- WRITE THIS AS A FILE!#
# 4) Stack RWL & Merge with metadata (becomes "ring.data" or named equivalent)#
# Ring.data format: stack all of the core BAI, so that data frame with a SIGNLE BAI column, and then all of the factors in other columns#
ring.data <- read.csv("TreeRWL_stacked.csv")#
ring.data$tree <- as.factor(ring.data$tree) #
summary(ring.data)#
#
tree.data <- read.csv("TreeData.csv")#
summary(tree.data)
min(ring.data[!is.na(ring.data$RW), "Year"])
for(i in unique(TreeID)){#
	yr <- min(ring.data[ring.data$TreeID==i & !is.na(ring.data$RW), "Year"])#
	ring.data[ring.data$TreeID==i & is.na(ring.data$RW), "RW0"] <- mean(ring.data[ring.data$TreeID==i & ring.data$Year==i:(i+10), "RW"])
}
for(i in unique(ring.data$TreeID)){#
	yr <- min(ring.data[ring.data$TreeID==i & !is.na(ring.data$RW), "Year"])#
	ring.data[ring.data$TreeID==i & is.na(ring.data$RW), "RW0"] <- mean(ring.data[ring.data$TreeID==i & ring.data$Year==i:(i+10), "RW"])#
}
for(i in unique(ring.data$TreeID)){#
	yr <- min(ring.data[ring.data$TreeID==i & !is.na(ring.data$RW), "Year"])#
	ring.data[ring.data$TreeID==i & is.na(ring.data$RW), "RW0"] <- mean(ring.data[ring.data$TreeID==i & ring.data$Year==yr:(yr+10), "RW"])#
}
warnings()
summary(ring.data)
ring.data$RW0 <- ring.data$RW
for(i in unique(ring.data$TreeID)){#
	yr <- min(ring.data[ring.data$TreeID==i & !is.na(ring.data$RW), "Year"])#
	ring.data[ring.data$TreeID==i & is.na(ring.data$RW), "RW0"] <- mean(ring.data[ring.data$TreeID==i & ring.data$Year==yr:(yr+10), "RW"])#
}
summary(ring.data)
for(i in unique(ring.data$TreeID)){#
	yr <- min(ring.data[ring.data$TreeID==i & !is.na(ring.data$RW), "Year"])#
	ring.data[ring.data$TreeID==i & is.na(ring.data$RW), "RW0"] <- mean(ring.data[ring.data$TreeID==i & ring.data$Year==yr:(yr+10), "RW"], na.rm=T)#
}
summary(ring.data)
i <- "MMA001"
yr <- min(ring.data[ring.data$TreeID==i & !is.na(ring.data$RW), "Year"])
yr
ring.data[ring.data$TreeID==i & ring.data$Year==yr, "RW"]
for(i in unique(ring.data$TreeID)){#
	yr <- min(ring.data[ring.data$TreeID==i & !is.na(ring.data$RW), "Year"])#
	ring.data[ring.data$TreeID==i & is.na(ring.data$RW), "RW0"] <- ring.data[ring.data$TreeID==i & ring.data$Year==yr, "RW"]#
}
summary(ring.data)
m1 <- gamm(RW0 ~ s(Year, bs="cs", k=3, by=TreeID) + species + dbh, random=list(site=~1, PlotID=~1), data=ring.data, na.action=na.omit)
par(mfrow=c(4,5), mar=c(2,2,0,0)+0.1)#
plot(m1$gam)
ring.data$RW.modeled <- predict(m1, ring.data)#
summary(ring.data)
ring.data$RW.modeled <- ifelse(ring.data$RW.modeled < 0, 0, ring.data$RW.modeled)#
summary(ring.data)
par(new=F)#
for(i in unique(ring.data$TreeID)){#
	plot(RW ~ Year, data=ring.data[ring.data$TreeID==i,], type="l", lwd=0.5, xlim=range(ring.data$Year, na.rm=T), ylim=range(ring.data$RW, na.rm=T))#
	par(new=T)#
}
par(new=F, mfrow=c(1,1), mar=c(5,5,0,0)+0.1)#
for(i in unique(ring.data$TreeID)){#
	plot(RW ~ Year, data=ring.data[ring.data$TreeID==i,], type="l", lwd=0.5, xlim=range(ring.data$Year, na.rm=T), ylim=range(ring.data$RW, na.rm=T))#
	par(new=T)#
}
for(i in unique(ring.data$TreeID)){#
	plot(RW.modeled ~ Year, data=ring.data[ring.data$TreeID==i & is.na(ring.data$RW),], type="p", cex=0.25, pch=19, col="red", xlim=range(ring.data$Year, na.rm=T), ylim=range(ring.data$RW, na.rm=T))#
	par(new=T)#
}
for(i in unique(ring.data$TreeID)){#
	plot(RW.modeled ~ Year, data=ring.data[ring.data$TreeID==i & is.na(ring.data$RW),], type="p", cex=0.4, pch=19, col="red", xlim=range(ring.data$Year, na.rm=T), ylim=range(ring.data$RW, na.rm=T))#
	par(new=T)#
}
plot(RW.modeled ~ RW, pch=19, xlim=c(0,1), ylim=c(0,1), data=ring.data[is.na(ring.data$RW),])
par(new=F)
plot(RW.modeled ~ RW, pch=19, xlim=c(0,1), ylim=c(0,1), data=ring.data[is.na(ring.data$RW),])
par(new=F)
plot(RW.modeled ~ RW, pch=19, xlim=c(0,1), ylim=c(0,1), data=ring.data[is.na(ring.data$RW),])
plot(RW.modeled ~ RW, pch=19, xlim=c(0,1), ylim=c(0,1), data=ring.data)
save(m1, file="GapFilling_gamm_mmf_2015.01.rData")
predict0 <- ring.data[,c("TreeID", "Year", "RW.modeled")]#
predict0$Year <- as.factor(predict0$Year)#
summary(predict0)
cores.predict <- recast(predict0, Year ~ TreeID)
cores.predict[1:10,1:10]#
cores.predict[(length(cores.predict[,1])-10):length(cores.predict[,1]),1:10]
write.csv(cores.predict, "Cores_RW_modeled.csv", row.names=F)
write.csv(cores.predict, "Trees_RW_modeled.csv", row.names=F)
predict0 <- ring.data[,c("TreeID", "Year", "RW.modeled")]#
predict0$Year <- as.factor(predict0$Year)#
summary(predict0)#
#
trees.predict <- recast(predict0, Year ~ TreeID)#
#summary(cores.predict)#
trees.predict [1:10,1:10]#
trees.predict [(length(trees.predict [,1])-10):length(trees.predict[,1]),1:10]#
#
write.csv(trees.predict, "Trees_RW_modeled.csv", row.names=F)
trees.obs <- ring.data[,c("TreeID", "Year", "BAI")]#
trees.obs $Year <- as.factor(trees.obs $Year)#
summary(trees.obs )
trees.obs <- ring.data[,c("TreeID", "Year", "RW")]#
trees.obs $Year <- as.factor(trees.obs $Year)#
summary(trees.obs )
trees.obs <- recast(trees.obs, Year ~ TreeID)
head(trees.obs[,1:10])
trees.obs[(length(trees.obs[,1])-10):length(trees.obs[,1]),1:10]
trees.gapfill <- as.data.frame(array(dim=dim(trees.obs)))
row.names(trees.gapfill) <- trees.obs$Year
names(trees.gapfill) <- names(trees.obs)
trees.gapfill <- trees.obs
trees.gapfill[is.na(trees.gapfill),] <- trees.predict[is.na(trees.gapfill),]
trees.gapfill <- trees.obs#
trees.gapfill[is.na(trees.gapfill),] <- trees.predict[is.na(trees.gapfill),]
trees.gapfill[is.na(trees.gapfill),1] <- trees.predict[is.na(trees.gapfill),1]
trees.gapfill[,1:10]
trees.gapfill[is.na(trees.gapfill),1]
trees.predict[is.na(trees.gapfill),1]
trees.predict[,1:10]
trees.gapfill[is.na(trees.gapfill[,1]),1] <- trees.predict[is.na(trees.gapfill[,1]),1]
trees.gapfill[,1:2]
trees.gapfill[,1:3]
trees.obs <- read.csv("Trees_RW_measured.csv", row.names=1)#
trees.predict <- read.csv("Trees_RW_modeled.csv", row.names=1)
trees.gapfill[is.na(trees.gapfill[,]),] <- trees.predict[is.na(trees.gapfill[,]),]
for(j in 1:ncol(trees.gapfill)){#
	trees.gapfill[is.na(trees.gapfill[,j]),j] <- trees.predict[is.na(trees.gapfill[,j]),j]#
	}
trees.gapfill[1:10,1:10]
trees.gapfill[(length(trees.gapfill[,1])-20):length(trees.gapfill[,1]),1:10]
min(trees.gapfill)
summary(trees.gapfill)
trees.obs <- read.csv("Trees_RW_measured.csv", row.names=1)#
trees.predict <- read.csv("Trees_RW_modeled.csv", row.names=1)
trees.gapfill <- trees.obs
summary(trees.obs)#
write.csv(trees.obs, "Trees_RW_measured.csv", row.names=F)
trees.obs <- read.csv("Trees_RW_measured.csv", row.names=1)#
trees.predict <- read.csv("Trees_RW_modeled.csv", row.names=1)
trees.gapfill <- trees.obs
for(j in 1:ncol(trees.gapfill)){#
	trees.gapfill[is.na(trees.gapfill[,j]),j] <- trees.predict[is.na(trees.gapfill[,j]),j]#
	}
trees.gapfill[1:10,1:10]
trees.gapfill[(length(trees.gapfill[,1])-20):length(trees.gapfill[,1]),1:10]
trees.gapfill[(length(trees.gapfill[,1])-20):length(trees.gapfill[,1]),1:10]
min(trees.gapfill)
dim(trees.gapfill)
write.csv(trees.gapfill, "Trees_RW_gapfilled.csv", row.names=T)
